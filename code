// Code for esp32 main board 


#define BLYNK_TEMPLATE_ID my templet id
#define BLYNK_TEMPLATE_NAME my name
#define BLYNK_AUTH_TOKEN my token


#include <BlynkSimpleEsp32.h>
#include <WiFi.h>
#include <HTTPClient.h>
#include <DHT.h>

// COREXY
#define STEP_PIN_1 12
#define DIR_PIN_1 13
#define STEP_PIN_2 14
#define DIR_PIN_2 27
#define FORWARD HIGH
#define BACKWARD LOW

// peripherals
#define FERTILIZER_PUMP_PIN 25
#define WATER_PUMP_PIN 26
#define RED_LED_PIN 22
#define BLUE_LED_PIN 21
#define BUZZER_PIN 23
#define LIMIT_RIGHT 32
#define LIMIT_LEFT 33
#define LIMIT_TOP 34
#define LIMIT_BOTTOM 35
#define SOIL_MOISTURE_PIN 39

#define DHTPIN 0
#define DHTTYPE DHT11
DHT dht(DHTPIN, DHTTYPE);

// Blynk
char auth[] = BLYNK_AUTH_TOKEN;
char ssid[] = "A";
char pass[] = "111111111";

bool autoModeActive = false;
bool manualModeActive = false;
bool sirenActive = false;
int currentX = 0, currentY = 0;

// Option A: static IP
const char* cam_url_detect = "http://10.69.251.154/detect";
const char* cam_url_stream = "http://10.69.251.154/stream";

// Option B: mDNS name (if you enabled MDNS on ESP32-CAM and your router supports it)
// const char* cam_url_detect = "http://esp32cam.local/detect";
// const char* cam_url_stream = "http://esp32cam.local/stream";


void verifyHomePosition() {
  Serial.println("Verifying Home Position...");

  digitalWrite(DIR_PIN_1, HIGH); digitalWrite(DIR_PIN_2, LOW);
  while (digitalRead(LIMIT_BOTTOM) != LOW) {
    digitalWrite(STEP_PIN_1, HIGH); digitalWrite(STEP_PIN_2, HIGH);
    delayMicroseconds(800);
    digitalWrite(STEP_PIN_1, LOW); digitalWrite(STEP_PIN_2, LOW);
    delayMicroseconds(800);
  }
  delay(300);

  digitalWrite(DIR_PIN_1, LOW); digitalWrite(DIR_PIN_2, LOW);
  while (digitalRead(LIMIT_LEFT) != LOW) {
    digitalWrite(STEP_PIN_1, HIGH); digitalWrite(STEP_PIN_2, HIGH);
    delayMicroseconds(800);
    digitalWrite(STEP_PIN_1, LOW); digitalWrite(STEP_PIN_2, LOW);
    delayMicroseconds(800);
  }
  currentX = 0; currentY = 0;
  Serial.println("‚úÖ Home verified");
}

void moveTo(int x, int y) {
  int dx = x - currentX;
  int dy = y - currentY;

  if (dx != 0) {
    digitalWrite(DIR_PIN_1, dx > 0 ? BACKWARD : FORWARD);
    digitalWrite(DIR_PIN_2, dx > 0 ? FORWARD : BACKWARD);
    for (int i = 0; i < abs(dx); i++) {
      digitalWrite(STEP_PIN_1, HIGH); digitalWrite(STEP_PIN_2, HIGH);
      delayMicroseconds(800);
      digitalWrite(STEP_PIN_1, LOW); digitalWrite(STEP_PIN_2, LOW);
      delayMicroseconds(800);
    }
  }

  if (dy != 0) {
    digitalWrite(DIR_PIN_1, dy > 0 ? FORWARD : BACKWARD);
    digitalWrite(DIR_PIN_2, dy > 0 ? FORWARD : BACKWARD);
    for (int i = 0; i < abs(dy); i++) {
      digitalWrite(STEP_PIN_1, HIGH); digitalWrite(STEP_PIN_2, HIGH);
      delayMicroseconds(800);
      digitalWrite(STEP_PIN_1, LOW); digitalWrite(STEP_PIN_2, LOW);
      delayMicroseconds(800);
    }
  }

  currentX = x; currentY = y;
  delay(500);
}

bool isDiseasedLeaf() {
  HTTPClient http;
  http.begin(cam_url_detect);
  int httpCode = http.GET();
  if (httpCode == 200) {
    String payload = http.getString();
    return payload.indexOf("whiteDot's") >= 0;
  }
  return false;
}

void checkPlant(int x, int y, String name) {
  if (!autoModeActive) return;

  moveTo(x, y);
  delay(2000);

  if (isDiseasedLeaf()) {
    Serial.println(name + " diseased, fertilizing");
    Blynk.virtualWrite(V4, name + " diseased (getting fertilizer)");

    // Fertilizer pump ON
    digitalWrite(FERTILIZER_PUMP_PIN, LOW);

    // Start siren pulse for 4 seconds
    unsigned long startTime = millis();
    bool ledState = false;

    while (millis() - startTime < 4000) {
      ledState = !ledState;
      digitalWrite(RED_LED_PIN, ledState ? HIGH : LOW);
      digitalWrite(BLUE_LED_PIN, ledState ? LOW : HIGH);
      digitalWrite(BUZZER_PIN, ledState ? HIGH : LOW);
      Blynk.virtualWrite(V11, ledState);  // Blynk siren indicator
      delay(300);
    }

    // Stop fertilizer, siren, buzzer
    digitalWrite(FERTILIZER_PUMP_PIN, HIGH);
    digitalWrite(RED_LED_PIN, LOW);
    digitalWrite(BLUE_LED_PIN, LOW);
    digitalWrite(BUZZER_PIN, LOW);
    Blynk.virtualWrite(V11, 0);

  } else {
    Serial.println(name + " healthy");
    Blynk.virtualWrite(V4, name + " healthy");
  }
}


// BLYNK callbacks
BLYNK_WRITE(V20) {  // auto mode
  autoModeActive = param.asInt();
  if (autoModeActive) {
    manualModeActive = false;
  }
}
BLYNK_WRITE(V21) {  // manual mode
  manualModeActive = param.asInt();
  if (manualModeActive) {
    autoModeActive = false;
  }
}
BLYNK_WRITE(V10) {  // image capture
  if (manualModeActive && param.asInt()) {
    Blynk.virtualWrite(V30, cam_url_stream);
  }
}
BLYNK_WRITE(V12) { if(manualModeActive && param.asInt()) moveTo(currentX,currentY+200); }
BLYNK_WRITE(V13) { if(manualModeActive && param.asInt()) moveTo(currentX,currentY-200); }
BLYNK_WRITE(V14) { if(manualModeActive && param.asInt()) moveTo(currentX-200,currentY); }
BLYNK_WRITE(V15) { if(manualModeActive && param.asInt()) moveTo(currentX+200,currentY); }
BLYNK_WRITE(V16) { if(manualModeActive) digitalWrite(FERTILIZER_PUMP_PIN, !param.asInt()); }
BLYNK_WRITE(V17) { if(manualModeActive) digitalWrite(WATER_PUMP_PIN, !param.asInt()); }
BLYNK_WRITE(V18) { // emergency stop
  digitalWrite(STEP_PIN_1, LOW); digitalWrite(STEP_PIN_2, LOW);
  digitalWrite(FERTILIZER_PUMP_PIN, HIGH);
  digitalWrite(WATER_PUMP_PIN, HIGH);
}

void soilMoistureTask(void *pv) {
  for (;;) {
    int val = analogRead(SOIL_MOISTURE_PIN);
    Blynk.virtualWrite(V0, val);
    Blynk.virtualWrite(V1, val > 2000 ? "Soil dry" : "Soil wet");
    digitalWrite(WATER_PUMP_PIN, val > 2000 ? LOW : HIGH);
    vTaskDelay(5000/portTICK_PERIOD_MS);
  }
}

void dhtTask(void *pv) {
  for(;;) {
    float t = dht.readTemperature();
    float h = dht.readHumidity();
    Blynk.virtualWrite(V2, t);
    Blynk.virtualWrite(V3, h);
    vTaskDelay(5000/portTICK_PERIOD_MS);
  }
}

void setup() {
  Serial.begin(115200);
  pinMode(STEP_PIN_1, OUTPUT); pinMode(DIR_PIN_1, OUTPUT);
  pinMode(STEP_PIN_2, OUTPUT); pinMode(DIR_PIN_2, OUTPUT);
  pinMode(FERTILIZER_PUMP_PIN, OUTPUT); digitalWrite(FERTILIZER_PUMP_PIN, HIGH);
  pinMode(WATER_PUMP_PIN, OUTPUT); digitalWrite(WATER_PUMP_PIN, HIGH);
  pinMode(RED_LED_PIN, OUTPUT); pinMode(BLUE_LED_PIN, OUTPUT); pinMode(BUZZER_PIN, OUTPUT);
  pinMode(LIMIT_LEFT, INPUT_PULLUP); pinMode(LIMIT_BOTTOM, INPUT_PULLUP);

  dht.begin();
  WiFi.begin(ssid, pass);
  Blynk.begin(auth, ssid, pass);
  verifyHomePosition();

  xTaskCreatePinnedToCore(soilMoistureTask,"soilTask",4096,NULL,1,NULL,1);
  xTaskCreatePinnedToCore(dhtTask,"dhtTask",4096,NULL,1,NULL,1);
}

void loop() {
  Blynk.run();

  if (autoModeActive) {
    checkPlant(0, 200, "P1");
    checkPlant(900, 200, "P2");
    checkPlant(1900, 200, "P3");
    checkPlant(0, 1500, "P4");
    checkPlant(900, 1500, "P5");
    checkPlant(1900, 1500, "P6");
    moveTo(0,0);
    Blynk.virtualWrite(V4,"Auto cycle complete");
    delay(10000);
  }
}


// Code for esp32 Cam

#include <WiFi.h>
#include <WebServer.h>
#include <esp_camera.h>
#include <leafDiseaseDetection1_inferencing.h>
#include "edge-impulse-sdk/dsp/image/image.hpp"

// ==== CAMERA CONFIGURATION: AI Thinker ====
#define PWDN_GPIO_NUM     32
#define RESET_GPIO_NUM    -1
#define XCLK_GPIO_NUM      0
#define SIOD_GPIO_NUM     26
#define SIOC_GPIO_NUM     27
#define Y9_GPIO_NUM       35
#define Y8_GPIO_NUM       34
#define Y7_GPIO_NUM       39
#define Y6_GPIO_NUM       36
#define Y5_GPIO_NUM       21
#define Y4_GPIO_NUM       19
#define Y3_GPIO_NUM       18
#define Y2_GPIO_NUM        5
#define VSYNC_GPIO_NUM    25
#define HREF_GPIO_NUM     23
#define PCLK_GPIO_NUM     22

// ==== WIFI CREDENTIALS ====
const char* ssid = "A";
const char* password = "111111111";
const char* deviceName = "ESP32-CAM-LEAF";

// ==== CAMERA SETTINGS ====
static camera_config_t camera_config = {
  .pin_pwdn       = PWDN_GPIO_NUM,
  .pin_reset      = RESET_GPIO_NUM,
  .pin_xclk       = XCLK_GPIO_NUM,
  .pin_sscb_sda   = SIOD_GPIO_NUM,
  .pin_sscb_scl   = SIOC_GPIO_NUM,
  .pin_d7         = Y9_GPIO_NUM,
  .pin_d6         = Y8_GPIO_NUM,
  .pin_d5         = Y7_GPIO_NUM,
  .pin_d4         = Y6_GPIO_NUM,
  .pin_d3         = Y5_GPIO_NUM,
  .pin_d2         = Y4_GPIO_NUM,
  .pin_d1         = Y3_GPIO_NUM,
  .pin_d0         = Y2_GPIO_NUM,
  .pin_vsync      = VSYNC_GPIO_NUM,
  .pin_href       = HREF_GPIO_NUM,
  .pin_pclk       = PCLK_GPIO_NUM,
  .xclk_freq_hz   = 20000000,
  .ledc_timer     = LEDC_TIMER_0,
  .ledc_channel   = LEDC_CHANNEL_0,
  .pixel_format   = PIXFORMAT_JPEG,
  .frame_size     = FRAMESIZE_QQVGA,     // Reduced resolution
  .jpeg_quality   = 20,                  // Increased compression
  .fb_count       = 1,
  .fb_location    = CAMERA_FB_IN_PSRAM,
  .grab_mode      = CAMERA_GRAB_WHEN_EMPTY
};

// ==== VARIABLES ====
WebServer server(80);
uint8_t* snapshot_buf;

#define EI_CAMERA_RAW_FRAME_BUFFER_COLS 160
#define EI_CAMERA_RAW_FRAME_BUFFER_ROWS 120
#define EI_CAMERA_FRAME_BYTE_SIZE 3

// ==== AI Inference Image Capture ====
bool ei_camera_capture(uint32_t img_width, uint32_t img_height, uint8_t* out_buf) {
  camera_fb_t* fb = esp_camera_fb_get();
  if (!fb) return false;

  bool converted = fmt2rgb888(fb->buf, fb->len, PIXFORMAT_JPEG, out_buf);
  esp_camera_fb_return(fb);

  if (!converted) return false;

  if ((img_width != EI_CAMERA_RAW_FRAME_BUFFER_COLS) || (img_height != EI_CAMERA_RAW_FRAME_BUFFER_ROWS)) {
    ei::image::processing::crop_and_interpolate_rgb888(
      out_buf,
      EI_CAMERA_RAW_FRAME_BUFFER_COLS,
      EI_CAMERA_RAW_FRAME_BUFFER_ROWS,
      out_buf,
      img_width,
      img_height
    );
  }
  return true;
}

// ==== Helper for Edge Impulse Classifier ====
static int ei_camera_get_data(size_t offset, size_t length, float* out_ptr) {
  size_t pixel_ix = offset * 3;
  for (size_t i = 0; i < length; i++) {
    out_ptr[i] = (snapshot_buf[pixel_ix + 2] << 16) + (snapshot_buf[pixel_ix + 1] << 8) + snapshot_buf[pixel_ix];
    pixel_ix += 3;
  }
  return 0;
}

// ==== /DETECT ====
void handleDetect() {
  Serial.printf("üì¶ Free heap before alloc: %u bytes\n", ESP.getFreeHeap());
  snapshot_buf = (uint8_t*)heap_caps_malloc(EI_CAMERA_RAW_FRAME_BUFFER_COLS * EI_CAMERA_RAW_FRAME_BUFFER_ROWS * EI_CAMERA_FRAME_BYTE_SIZE, MALLOC_CAP_SPIRAM);
  if (!snapshot_buf) {
    server.send(500, "text/plain", "‚ùå Failed to allocate buffer");
    return;
  }

  if (!ei_camera_capture(EI_CLASSIFIER_INPUT_WIDTH, EI_CLASSIFIER_INPUT_HEIGHT, snapshot_buf)) {
    server.send(500, "text/plain", "‚ùå Image capture failed");
    free(snapshot_buf);
    return;
  }

  ei::signal_t signal;
  signal.total_length = EI_CLASSIFIER_INPUT_WIDTH * EI_CLASSIFIER_INPUT_HEIGHT;
  signal.get_data = &ei_camera_get_data;

  ei_impulse_result_t result = { 0 };
  EI_IMPULSE_ERROR res = run_classifier(&signal, &result, false);

  if (res != EI_IMPULSE_OK) {
    server.send(500, "text/plain", "‚ùå Classifier failed");
    free(snapshot_buf);
    return;
  }

  String status = "Healthy";
  for (uint16_t i = 0; i < EI_CLASSIFIER_LABEL_COUNT; i++) {
    if (String(ei_classifier_inferencing_categories[i]) == "whiteDot's" && result.classification[i].value > 0.6) {
      status = "whiteDot's";
      break;
    }
  }

  free(snapshot_buf);
  server.send(200, "text/plain", status);
}

// ==== /STREAM ====
void handleStream() {
  WiFiClient client = server.client();
  String response = "HTTP/1.1 200 OK\r\n";
  response += "Content-Type: multipart/x-mixed-replace; boundary=frame\r\n\r\n";
  client.print(response);

  while (client.connected()) {
    camera_fb_t* fb = esp_camera_fb_get();
    if (!fb) continue;

    client.printf("--frame\r\nContent-Type: image/jpeg\r\nContent-Length: %u\r\n\r\n", fb->len);
    client.write(fb->buf, fb->len);
    client.print("\r\n");

    esp_camera_fb_return(fb);
    delay(100);
  }
}

// ==== /CAPTURE ====
void handleCapture() {
  camera_fb_t* fb = esp_camera_fb_get();
  if (!fb) {
    server.send(500, "text/plain", "‚ùå Camera capture failed");
    return;
  }
  server.send_P(200, "image/jpeg", (char*)fb->buf, fb->len);
  esp_camera_fb_return(fb);
}

// ==== SETUP ====
void setup() {
  Serial.begin(115200);
  Serial.println();
  Serial.printf("üîå Device: %s\n", deviceName);
  Serial.printf("üì¶ Heap at boot: %u bytes\n", ESP.getFreeHeap());

  if (esp_camera_init(&camera_config) != ESP_OK) {
    Serial.println("‚ùå Camera init failed!");
    return;
  }

  WiFi.begin(ssid, password);
  Serial.printf("üåê Connecting to WiFi: %s\n", ssid);
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }

  Serial.println("\n‚úÖ WiFi connected");
  Serial.print("üì∂ IP address: ");
  Serial.println(WiFi.localIP());

  server.on("/detect", handleDetect);
  server.on("/stream", handleStream);
  server.on("/capture", handleCapture);
  server.begin();
  Serial.println("üåê HTTP server started");
}

// ==== LOOP ====
void loop() {
  server.handleClient();
}
